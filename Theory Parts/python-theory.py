# PYTHON TUTORIALS:
# 1. Introduction to Python
# 2. Python Syntax
# 3. Variables and Data Types
# 4. Operators
# 5. Input and Output
# 6. Control Statements
# 7. Data Structures
# 8. Functions
# 9. In-built Functions
# 10. Scope
# 11. Modules and Packages
# 12. OOPs (Object-Oriented Programming)
# 13. File Handling
# 14. Exception Handling
# 15. Advanced Python Concepts
# 16. Standard Libraries


# ------------------------------------------------------------------------------------------------------------------------------



# What is Python ?
# Python is a high-level, interpreted programming language known for its readability and versatility.
# It supports multiple programming paradigms, including procedural, object-oriented, and functional programming.
# Python is widely used in web development, data analysis, artificial intelligence, scientific computing, and more.
# It has a large standard library and a vibrant ecosystem of third-party packages, making it suitable for a wide range of applications.
# Python is designed to be easy to read and write, with a syntax that emphasizes code readability and simplicity.
# It is dynamically typed, meaning that variable types are determined at runtime, and it supports automatic memory management through garbage collection.
# Python is an open-source language, which means that its source code is freely available and can be modified and distributed by anyone.
# It is maintained by the Python Software Foundation and has a large and active community of developers who contribute to its development and support.
# Python is cross-platform, meaning that it can run on various operating systems, including Windows, macOS, and Linux.
# It is also widely used in education, as it is often recommended as a first programming language for beginners due to its simplicity and ease of use.
# Python is known for its extensive libraries and frameworks, such as NumPy, Pandas, Django, Flask, and TensorFlow, which provide powerful tools for data manipulation, web development, and machine learning.
# Overall, Python is a versatile and powerful programming language that is widely used in various fields and industries, making it a valuable skill for developers and data scientists alike.


# ------------------------------------------------------------------------------------------------------------------------------


# What is the Syntax of Python ?
# print("Hello, World!")


# ------------------------------------------------------------------------------------------------------------------------------


# Variables :
# Variables are used to store data values. In Python, you don't need to declare the variable type explicitly.
# The type is inferred from the value assigned to the variable.
# Variable names can contain letters, numbers, and underscores, but cannot start with a number.
# Python is case-sensitive, so "myVar" and "myvar" are different variables.
# Python supports dynamic typing, meaning you can change the type of a variable by assigning a new value to it.
# Python also supports multiple assignment, allowing you to assign values to multiple variables in a single line.


# ------------------------------------------------------------------------------------------------------------------------------


#  Types of Variables: 
# 1. Integer: Whole numbers, e.g., 5, -10, 0
# 2. Float: Decimal numbers, e.g., 3.14, -0.5, 2.0
# 3. String: Text enclosed in quotes, e.g., "Hello", 'Python'
# 4. Boolean: True or False values, e.g., True, False
# 5. List: Ordered collection of items, e.g., [1, 2, 3], ["apple", "banana"]
# 6. Tuple: Immutable ordered collection of items, e.g., (1, 2, 3), ("apple", "banana")
# 7. Dictionary: Key-value pairs, e.g., {"name": "Alice", "age": 25}
# 8. Set: Unordered collection of unique items, e.g., {1, 2, 3}, {"apple", "banana"}


# ------------------------------------------------------------------------------------------------------------------------------

# What is Data Types ?
# Data types are classifications of data that determine the type of value a variable can hold and the operations that can be performed on it.
# In Python, data types are dynamic, meaning you don't need to declare the type explicitly.
# The type is inferred from the value assigned to the variable.
# Python has several built-in data types, including:
# 1. Numeric Types: Integer (int), Float (float), Complex (complex)
# 2. Sequence Types: String (str), List (list), Tuple (tuple)
# 3. Mapping Type: Dictionary (dict)
# 4. Set Types: Set (set), Frozen Set (frozenset)
# 5. Boolean Type: Boolean (bool)

# Data Types:
# 1. Integer: Whole numbers, e.g., 5, -10, 0
# 2. Float: Decimal numbers, e.g., 3.14, -0.5, 2.0
# 3. Complex: Complex numbers, e.g., 2 + 3j
# 4. String: Text enclosed in quotes, e.g., "Hello", 'Python'
# 5. Boolean: True or False values, e.g., True, False
# 6. List: Ordered collection of items, e.g., [1, 2, 3], ["apple", "banana"]
# 7. Tuple: Immutable ordered collection of items, e.g., (1, 2, 3), ("apple", "banana")
# 8. Dictionary: Key-value pairs, e.g., {"name": "Alice", "age": 25}
# 9. Set: Unordered collection of unique items, e.g., {1, 2, 3}, {"apple", "banana"}


# ------------------------------------------------------------------------------------------------------------------------------

# What is Operators ?
# Operators are symbols that perform operations on variables and values. 
# Python supports various types of operators, including arithmetic, comparison, logical, assignment, bitwise, membership, and identity operators.
# Operators are used to manipulate data and variables in Python.
# They can be classified into several categories based on their functionality:
# 1. Arithmetic Operators: Used for mathematical operations (addition, subtraction, multiplication, division, etc.).
# 2. Comparison Operators: Used to compare values (equal to, not equal to, greater than, less than, etc.).
# 3. Logical Operators: Used to perform logical operations (and, or, not).
# 4. Assignment Operators: Used to assign values to variables (simple assignment, compound assignment).
# 5. Bitwise Operators: Used to perform bitwise operations (AND, OR, XOR, NOT, left shift, right shift).
# 6. Membership Operators: Used to check membership in sequences (in, not in).
# 7. Identity Operators: Used to check the identity of objects (is, is not).

# Operators:
# 1. Arithmetic Operators: +, -, *, /, // (floor division), % (modulus), ** (exponentiation)
# 2. Comparison Operators: ==, !=, >, <, >=, <=
# 3. Logical Operators: and, or, not
# 4. Assignment Operators: =, +=, -=, *=, /=, //=, %=, **=
# 5. Bitwise Operators: &, |, ^, ~, <<, >>
# 6. Membership Operators: in, not in
# 7. Identity Operators: is, is not


# ------------------------------------------------------------------------------------------------------------------------------


# Input and Output:
# 1. Input: Use the input() function to get user input. It returns a string.
#    Example: name = input("Enter your name: ")
# 2. Output: Use the print() function to display output.
#    Example: print("Hello, " + name)


# ------------------------------------------------------------------------------------------------------------------------------

# What is Control Statements ?
# Control statements are used to control the flow of execution in a program based on certain conditions or loops.
# They allow you to make decisions, repeat actions, and manage the flow of the program.
# In Python, control statements include conditional statements (if, elif, else), loops (for, while), and control flow statements (break, continue, pass).
# Control statements help you implement logic and control the execution of code blocks based on specific conditions or iterations.
# They are essential for creating dynamic and interactive programs.
# Control statements allow you to handle different scenarios and make decisions based on user input or program state.
# They enable you to create loops for repetitive tasks and manage the flow of execution in a structured manner.
# Control statements are fundamental to programming and are used in almost every program to implement logic and control the flow of execution.
# Control statements are classified into various types based on their functionality:
# 1. Conditional Statements: Used to execute a block of code based on a condition (if, elif, else).
# 2. Loops: Used to repeat a block of code multiple times (for, while).
# 3. Break and Continue: Used to control the flow of loops (break exits the loop, continue skips to the next iteration).
# 4. Pass: A placeholder statement that does nothing (used when a statement is syntactically required but no action is needed).
# 5. Nested Loops: Loops inside loops to create complex iterations.
# 6. Control Flow Statements: Used to manage the flow of execution in a program (break, continue, pass).

# Types of Control Statements:
# 1. Conditional Statements: if, elif, else
# 2. Loops: for, while
# 3. Break and Continue: break, continue
# 4. Pass: pass (used as a placeholder)
# 5. Nested Loops: Loops inside loops.
# 6. Control Flow Statements: break, continue, pass (used to control the flow of loops).


# ------------------------------------------------------------------------------------------------------------------------------


#  Control Statements:
# 1. Conditional Statements: Use if, elif, and else to control the flow of the program based on conditions.
#    Example:
#    if age >= 18:
#        print("You are an adult.")
#    elif age >= 13:
#        print("You are a teenager.")
#    else:
#        print("You are a child.")
# 2. Loops: Use for and while loops to iterate over a sequence or execute a block of code repeatedly.
#    Example:
#    for i in range(5):
#        print(i)
#    while condition:
#        # code block
#        break  # Exit the loop
#        continue  # Skip to the next iteration
# 3. Break and Continue: Use break to exit a loop and continue to skip to the next iteration of a loop.
#    Example:
#    for i in range(10):
#        if i == 5:
#            break  # Exit the loop when i is 5
#        print(i)
#    for i in range(10):
#        if i % 2 == 0:
#            continue  # Skip even numbers
#        print(i)  # Print only odd numbers
# 4. Pass: Use pass as a placeholder for future code. It does nothing and is used when a statement is syntactically required but no action is needed.
#    Example:
#    if condition:
#        pass  # Placeholder for future code
#    for i in range(10):
#        pass  # Placeholder for future code
#    while condition:
#        pass  # Placeholder for future code
# 5. Nested Loops: You can nest loops inside each other to create complex iterations.
#    Example:
#    for i in range(3):
#        for j in range(2):
#            print(i, j)  # Print pairs of i and j


# ------------------------------------------------------------------------------------------------------------------------------


# Data Structures:
# 1. List: Ordered collection of items, mutable (can be changed), allows duplicates.
#    Example: my_list = [1, 2, 3, "apple", True]
#    List methods: append(), extend(), insert(), remove(), pop(), sort(), reverse(), index(), count()
# 2. Tuple: Immutable ordered collection of items, allows duplicates.
#    Example: my_tuple = (1, 2, 3, "apple", True)
#    Tuple methods: count(), index()
# 3. Dictionary: Unordered collection of key-value pairs, mutable, keys must be unique.
#    Example: my_dict = {"name": "Alice", "age": 25, "city": "New York"}
#    Dictionary methods: keys(), values(), items(), get(), pop(), update(), clear()
# 4. Set: Unordered collection of unique items, mutable, does not allow duplicates.
#    Example: my_set = {1, 2, 3, "apple", True}


# ------------------------------------------------------------------------------------------------------------------------------


# Functions:
# 1. Function Definition: Use the def keyword to define a function.
#    Example:
#    def greet(name):
#        print("Hello, " + name)
#    greet("Alice")  # Call the function with an argument
# 2. Function Parameters: Functions can take parameters (inputs) and return values.
#    Example:
#    def add(a, b):
#        return a + b
#    result = add(5, 3)  # Call the function with arguments
#    print(result)  # Output: 8
# 3. Default Parameters: You can set default values for function parameters.
#    Example:
#    def greet(name="World"):
#        print("Hello, " + name)
#    greet()  # Output: Hello, World
#    greet("Alice")  # Output: Hello, Alice
# 4. Keyword Arguments: You can pass arguments by keyword, allowing you to specify which parameter to assign a value to.
#    Example:
#    def greet(name, age):
#        print("Hello, " + name + ". You are " + str(age) + " years old.")
#    greet(age=25, name="Alice")  # Output: Hello, Alice. You are 25 years old.
# 5. Lambda Functions: Anonymous functions defined using the lambda keyword. They can take any number of arguments but can only have one expression.
#    Example:
#    add = lambda x, y: x + y
#    result = add(5, 3)  # Call the lambda function
#    print(result)  # Output: 8


# ------------------------------------------------------------------------------------------------------------------------------


# In-built Functions:
# 1. print(): Displays output to the console.
# 2. input(): Reads input from the user.
# 3. len(): Returns the length of an object (string, list, tuple, etc.).
# 4. type(): Returns the type of an object.
# 5. str(): Converts an object to a string.
# 6. int(): Converts an object to an integer.
# 7. float(): Converts an object to a float.
# 8. list(): Converts an iterable to a list.
# 9. tuple(): Converts an iterable to a tuple.
# 10. dict(): Creates a dictionary from key-value pairs.
# 11. set(): Creates a set from an iterable.
# 12. range(): Generates a sequence of numbers.
# 13. sum(): Returns the sum of all items in an iterable.
# 14. max(): Returns the largest item in an iterable or the largest of two or more arguments.
# 15. min(): Returns the smallest item in an iterable or the smallest of two or more arguments.
# 16. sorted(): Returns a sorted list of the specified iterable's items.
# 17. reversed(): Returns a reversed iterator of the specified iterable.
# 18. map(): Applies a function to all items in an iterable and returns a map object (iterator).
# 19. filter(): Filters items in an iterable based on a function and returns a filter object (iterator).
# 20. zip(): Combines multiple iterables into a single iterable of tuples.
# 21. enumerate(): Adds a counter to an iterable and returns it as an enumerate object (iterator).
# 22. all(): Returns True if all items in an iterable are true (or if the iterable is empty).
# 23. any(): Returns True if any item in an iterable is true. If the iterable is empty, returns False.
# 24. eval(): Evaluates a string as a Python expression and returns the result.
# 25. ord(): Returns the Unicode code point of a character.
# 26. chr(): Returns the character corresponding to a Unicode code point.
# 27. abs(): Returns the absolute value of a number.
# 28. round(): Rounds a number to a specified number of decimal places.
# 29. isinstance(): Checks if an object is an instance of a specified class or type.
# 30. id(): Returns the unique identifier of an object.
# 31. dir(): Returns a list of the attributes and methods of an object.
# 32. help(): Displays the documentation for an object or function.
# 33. bin(): Converts an integer to a binary string.
# 34. oct(): Converts an integer to an octal string.
# 35. hex(): Converts an integer to a hexadecimal string.


# ------------------------------------------------------------------------------------------------------------------------------


# Scope:
# 1. Local Scope: Variables defined inside a function are local to that function and cannot be accessed outside of it.
#    Example:
#    def my_function():
#        x = 10  # Local variable
#        print(x)  # Accessible inside the function
#    my_function()  # Output: 10
#    print(x)  # Error: x is not defined outside the function
# 2. Global Scope: Variables defined outside of any function are global and can be accessed anywhere in the code.
#    Example:
#    x = 5  # Global variable
#    def my_function():
#        print(x)  # Accessible inside the function
#    my_function()  # Output: 5
#    print(x)  # Output: 5
# 3. Nonlocal Scope: Used in nested functions to refer to variables in the nearest enclosing scope that is not global.
#    Example:
#    def outer_function():
#        x = "outer"
#        def inner_function():
#            nonlocal x  # Refers to the variable x in the outer function
#            x = "inner"  # Modify the variable in the outer function
#            print("Inner:", x)  # Output: Inner: inner
#        inner_function()
#        print("Outer:", x)  # Output: Outer: inner
#    outer_function()


# ------------------------------------------------------------------------------------------------------------------------------

# Modules and Packages:
# 1. Module: A file containing Python code (functions, classes, variables) that can be imported and used in other Python files.
#    Example: import math  # Import the math module
#    Example: from math import sqrt  # Import only the sqrt function from the math module
#    Example: import math as m  # Import the math module with an alias
#    Example: from math import *  # Import all functions and variables from the math module
# 2. Package: A collection of related modules organized in a directory hierarchy. Packages can contain sub-packages and modules.
#    Example: import numpy as np  # Import the NumPy package with an alias
#    Example: from scipy import stats  # Import the stats module from the SciPy package
#    Example: from sklearn.model_selection import train_test_split  # Import the train_test_split function from the model_selection module in the scikit-learn package
# 3. Creating a Module: You can create your own module by saving Python code in a .py file and importing it in other files.
#    Example: Create a file named my_module.py with functions and variables, then import it in another file using import my_module.
#    Example: from my_module import my_function  # Import a specific function from your module
#    Example: import my_module as mm  # Import your module with an alias
#    Example: from my_module import *  # Import all functions and variables from your module
# 4. Use pip to install third-party packages from the Python Package Index (PyPI).
#    Example: pip install numpy  # Install the NumPy package
#    Example: pip install pandas  # Install the Pandas package
#    Example: pip install flask  # Install the Flask package


# ------------------------------------------------------------------------------------------------------------------------------


# OOPs (Object-Oriented Programming):
# 1. Class: A blueprint for creating objects. 
# It defines attributes (data) and methods (functions) that the objects created from the class can have.
#    Example:
#    class Dog:
#        def __init__(self, name, age):
#            self.name = name  # Attribute
#            self.age = age  # Attribute
#        def bark(self):  # Method
#            print("Woof! My name is " + self.name)
#    my_dog = Dog("Buddy", 3)  # Create an object of the Dog class
#    my_dog.bark()  # Call the bark method of the Dog object
# 2. Object: An instance of a class. It contains data and methods defined in the class.
#    Example:
#    my_dog = Dog("Buddy", 3)  # Create an object of the Dog class
#    my_dog.bark()  # Call the bark method of the Dog object
# 3. Method: A function defined inside a class that operates on the attributes of the class.
#    Example:
#    class Dog:
#        def __init__(self, name, age):
#            self.name = name  # Attribute
#            self.age = age  # Attribute
#        def bark(self):  # Method
#            print("Woof! My name is " + self.name)
#    my_dog = Dog("Buddy", 3)  # Create an object of the Dog class
#    my_dog.bark()  # Call the bark method of the Dog object
# 4. Inheritance: A way to create a new class (child class) based on an existing class (parent class). 
# The child class inherits attributes and methods from the parent class.
#    Example:
#    class Animal:
#        def __init__(self, species):
#            self.species = species  # Attribute
#        def make_sound(self):
#            print("Animal sound")
#    class Dog(Animal):  # Inherit from Animal class
#        def __init__(self, name, age):
#            super().__init__("Dog")  # Call the parent class constructor
#            self.name = name  # Attribute
#            self.age = age  # Attribute
#        def bark(self):  # Method
#            print("Woof! My name is " + self.name)
#    my_dog = Dog("Buddy", 3)  # Create an object of the Dog class
#    my_dog.bark()  # Call the bark method of the Dog object
#    my_dog.make_sound()  # Call the make_sound method of the Animal class
# 5. Polymorphism: The ability to use a single interface to represent different data types.
# It allows methods to be defined in a way that they can be used with different classes.
#    Example:
#    class Cat(Animal):  # Inherit from Animal class
#        def make_sound(self):
#            print("Meow!")
#    class Dog(Animal):  # Inherit from Animal class
#        def make_sound(self):
#            print("Woof!")
#    def animal_sound(animal):  # Function that takes an Animal object
#        animal.make_sound()  # Call the make_sound method of the Animal class
#    my_cat = Cat("Whiskers")  # Create an object of the Cat class
#    my_dog = Dog("Buddy")  # Create an object of the Dog class
#    animal_sound(my_cat)  # Output: Meow!
#    animal_sound(my_dog)  # Output: Woof!
# 6. Encapsulation: The bundling of data (attributes) and methods (functions) that operate on the data into a single unit (class).
# It restricts direct access to some attributes and methods, providing a controlled interface for interacting with the object.
#    Example:
#    class BankAccount:
#        def __init__(self, balance):
#            self.__balance = balance  # Private attribute
#        def deposit(self, amount):  # Public method
#            self.__balance += amount  # Modify the private attribute
#        def withdraw(self, amount):  # Public method
#            if amount <= self.__balance:
#                self.__balance -= amount  # Modify the private attribute
#            else:
#                print("Insufficient funds")
#        def get_balance(self):  # Public method
#            return self.__balance  # Access the private attribute
#    my_account = BankAccount(1000)  # Create an object of the BankAccount class
#    my_account.deposit(500)  # Deposit money into the account
#    print(my_account.get_balance())  # Output: 1500
#    my_account.withdraw(200)  # Withdraw money from the account
#    print(my_account.get_balance())  # Output: 1300
#    my_account.__balance = 5000  # Attempt to modify the private attribute (not allowed)
#    print(my_account.get_balance())  # Output: 1300 (still 1300, not modified)
# 7. Abstraction: The concept of hiding the complex implementation details and showing only the essential features of the object.
# It allows the user to interact with the object without needing to understand the underlying complexity.
#    Example:
#    class Car:
#        def __init__(self, make, model):
#            self.make = make  # Attribute
#            self.model = model  # Attribute
#        def start_engine(self):  # Method
#            print("Engine started")  # Implementation detail
#        def drive(self):  # Method
#            print("Car is driving")  # Implementation detail
#    my_car = Car("Toyota", "Camry")  # Create an object of the Car class
#    my_car.start_engine()  # Start the engine (user interacts with the object)
#    my_car.drive()  # Drive the car (user interacts with the object)
#    # The user does not need to know how the engine works or how the car drives internally.
#    # They only need to know how to use the start_engine() and drive() methods.


# ------------------------------------------------------------------------------------------------------------------------------


# File Handling:
# 1. Opening a File: Use the open() function to open a file. It returns a file object.
#    Example:
#    file = open("example.txt", "r")  # Open a file in read mode
#    file = open("example.txt", "w")  # Open a file in write mode (creates a new file or overwrites existing file)
#    file = open("example.txt", "a")  # Open a file in append mode (adds content to the end of the file)
#    file = open("example.txt", "r+")  # Open a file in read and write mode
#    file = open("example.txt", "b")  # Open a file in binary mode (for non-text files)
#    file = open("example.txt", "x")  # Open a file in exclusive creation mode (fails if the file already exists)
# 2. Reading from a File: Use the read(), readline(), or readlines() methods to read data from a file.
#    Example:
#    content = file.read()  # Read the entire file content
#    line = file.readline()  # Read a single line from the file
#    lines = file.readlines()  # Read all lines into a list
#    for line in lines:
#        print(line.strip())  # Print each line without extra newline characters
# 3. Writing to a File: Use the write() or writelines() methods to write data to a file.
#    Example:
#    file.write("Hello, World!\n")  # Write a string to the file
#    file.writelines(["Line 1\n", "Line 2\n"])  # Write a list of strings to the file
# 4. Closing a File: Use the close() method to close a file after you are done with it.
#    Example:
#    file.close()  # Close the file
# 5. Context Manager: Use the with statement to automatically close a file after its block of code is executed
#    Example:
#    with open("example.txt", "r") as file:
#        content = file.read()  # Read the entire file content
#        print(content)  # Print the file content
#    # The file is automatically closed after the with block ends
# 6. File Modes:
#    - "r": Read mode (default) - Opens a file for reading (file must exist).
#    - "w": Write mode - Opens a file for writing (creates a new file or overwrites existing file).
#    - "a": Append mode - Opens a file for appending (adds content to the end of the file).
#   - "rb": Read binary mode - Opens a file for reading in binary format.
#   - "wb": Write binary mode - Opens a file for writing in binary format (creates a new file or overwrites existing file).


# ------------------------------------------------------------------------------------------------------------------------------


# Exception Handling:
# 1. Try and Except: Use try and except blocks to handle exceptions (errors) that may occur during program execution.
#    Example:
#    try:
#        x = 10 / 0  # Division by zero (will raise an exception)
#    except ZeroDivisionError:
#        print("Cannot divide by zero")  # Handle the exception
#    except Exception as e:
#        print("An error occurred:", e)  # Handle any other exception
#    else:
#        print("No exceptions occurred")  # Code to execute if no exceptions occur
#    finally:
#        print("This block always executes")  # Code that always executes, regardless of exceptions
# 2. Finally: Use the finally block to specify code that should always.
#    Example:
#    try:
#        file = open("example.txt", "r")  # Open a file
#        content = file.read()  # Read the file content
#    except FileNotFoundError:
#        print("File not found")  # Handle the exception
#    finally:
#        file.close()  # Close the file (if it was opened)
# 3. Raising Exceptions: Use the raise statement to raise an exception manually.
#    Example:
#    def divide(a, b):
#        if b == 0:
#            raise ValueError("Cannot divide by zero")  # Raise a ValueError exception
#        return a / b  # Return the result of division
#    try:
#        result = divide(10, 0)  # Call the divide function
#    except ValueError as e:
#        print("Error:", e)  # Handle the exception
# 4. Custom Exceptions: You can create your own custom exception classes by inheriting from the built-in Exception class.
#    Example:
#    class CustomError(Exception):  # Custom exception class
#        pass  # Custom exception class can have additional attributes or methods
#    try:
#        raise CustomError("This is a custom error")  # Raise the custom exception
#    except CustomError as e:
#        print("Caught custom error:", e)  # Handle the custom exception


# ------------------------------------------------------------------------------------------------------------------------------


# Advanced Python Concepts:
# 1. List Comprehensions: A concise way to create lists using a single line of code.
#    Example:
#    squares = [x**2 for x in range(10)]  # Create a list of squares from 0 to 9
#    print(squares)  # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
#    even_squares = [x**2 for x in range(10) if x % 2 == 0]  # Create a list of squares of even numbers
#    print(even_squares)  # Output: [0, 4, 16, 36, 64]
# 2. Dictionary Comprehensions: A concise way to create dictionaries using a single line of code.
#    Example:
#    squares_dict = {x: x**2 for x in range(10)}  # Create a dictionary of squares from 0 to 9
#    print(squares_dict)  # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
#    even_squares_dict = {x: x**2 for x in range(10) if x % 2 == 0}  # Create a dictionary of squares of even numbers
#    print(even_squares_dict)  # Output: {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# Generator and Iterators:
# 1. Generator: A special type of iterator that generates values on the fly using the yield keyword.
#    Example:
#    def fibonacci(n):
#        a, b = 0, 1
#        for _ in range(n):
#            yield a  # Yield the current value of a
#            a, b = b, a + b  # Update a and b for the next iteration
#    fib_gen = fibonacci(10)  # Create a generator object
#    for num in fib_gen:
#        print(num)  # Print the Fibonacci numbers generated by the generator
#    # Output: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
# 2. Iterator: An object that implements the iterator protocol, which consists of the __iter__() and __next__() methods.
#    Example:
#    class MyIterator:
#        def __init__(self, data):
#            self.data = data  # Store the data
#            self.index = 0  # Initialize the index
#        def __iter__(self):
#            return self  # Return the iterator object itself
#        def __next__(self):
#            if self.index < len(self.data):
#                value = self.data[self.index]  # Get the current value
#                self.index += 1  # Increment the index
#                return value  # Return the current value
#            else:
#                raise StopIteration  # Raise StopIteration when there are no more values to iterate
#    my_iter = MyIterator([1, 2, 3, 4, 5])  # Create an iterator object
#    for value in my_iter:
#        print(value)  # Print the values generated by the iterator
#    # Output: 1, 2, 3, 4, 5
# 3. Decorators: A way to modify or enhance the behavior of functions or methods without changing their code.
#   Example:
#    def decorator_function(original_function):
#        def wrapper_function(*args, **kwargs):
#            print("Wrapper executed
#            return original_function(*args, **kwargs)  # Call the original function
#        return wrapper_function  # Return the wrapper function
#    @decorator_function  # Apply the decorator to the original function
#    def display():
#        print("Display function executed")  # Original function code
#    display()  # Call the decorated function
#    # Output:
#    Wrapper executed
#    Display function executed
# 4. Context Managers: A way to manage resources (like files) using the with statement, ensuring proper cleanup after use.
#    Example:
#    with open("example.txt", "r") as file:
#        content = file.read()  # Read the file content
#        print(content)  # Print the file content
#    # The file is automatically closed after the with block ends
#    # No need to explicitly call file.close()


# ------------------------------------------------------------------------------------------------------------------------------

# Standard Libraries:
# 1. os: Provides functions for interacting with the operating system (file and directory operations).
#    Example:
#    import os  # Import the os module
#    os.mkdir("new_directory")  # Create a new directory
#    os.chdir("new_directory")  # Change the current working directory
#    os.listdir()  # List files and directories in the current directory
#    os.remove("file.txt")  # Remove a file
#    os.rmdir("new_directory")  # Remove a directory
# 2. sys: Provides access to system-specific parameters and functions (command-line arguments, system exit).
#    Example:
#    import sys  # Import the sys module
#    print(sys.argv)  # Print command-line arguments passed to the script
#    sys.exit(0)  # Exit the program with a status code
# 3. math: Provides mathematical functions and constants (trigonometric functions, logarithms, etc.).
#    Example:
#    import math  # Import the math module
#    print(math.sqrt(16))  # Output: 4.0 (square root of 16)
#    print(math.pi)  # Output: 3.141592653589793 (value of pi)
#    print(math.factorial(5))  # Output: 120 (factorial of 5)
# 5. datetime: Provides classes for manipulating dates and times (date, time, datetime, timedelta).
#    Example:
#    from datetime import datetime  # Import the datetime class
#    now = datetime.now()  # Get the current date and time
#    print(now)  # Output: Current date and time
#    print(now.strftime("%Y-%m-%d %H:%M:%S"))  # Format the date and time as a string
#    # Output: 2023-10-01 12:34:56 (example output)
#    print(now + timedelta(days=7))  # Add 7 days to the current date
#    # Output: 2023-10-08 12:34:56 (example output)
# 6. json: Provides functions for working with JSON data (encoding and decoding JSON).
#    Example:
#    import json  # Import the json module
#    data = {"name": "Alice", "age": 25}  # Sample data
#    json_string = json.dumps(data)  # Convert Python object to JSON string
#    print(json_string)  # Output: {"name": "Alice", "age": 25}
#    data = json.loads(json_string)  # Convert JSON string back to Python object
#    print(data)  # Output: {'name': 'Alice', 'age': 25}
# 7. pickle: Provides functions for serializing and deserializing Python objects (saving and loading objects).
#    Example:
#    import pickle  # Import the pickle module
#    data = {"name": "Alice", "age": 25}  # Sample data
#    with open("data.pkl", "wb") as file:  # Open a file in binary write mode
#        pickle.dump(data, file)  # Serialize and save the data to the file
#    with open("data.pkl", "rb") as file:  # Open the file in binary read mode
#        loaded_data = pickle.load(file)  # Load and deserialize the data from the file
#    print(loaded_data)  # Output: {'name': 'Alice', 'age
#    25}
# 8. re: Provides functions for working with regular expressions (pattern matching and string manipulation).
#    Example:
#    import re  # Import the re module
#    pattern = r"\d+"  # Regular expression pattern to match digits
#    text = "There are 123 apples and 456 oranges."  # Sample text
#    matches = re.findall(pattern, text)  # Find all matches of the pattern in the text
#    print(matches)  # Output: ['123', '456'] (list of matched digits)
#    match = re.search(pattern, text)  # Search for the first match of the pattern in the text
#    if match:
#        print(match.group())  # Output: 123 (first matched digits)
#    replaced_text = re.sub(pattern, "X", text)  # Replace all matches of the pattern with "X"
#    print(replaced_text)  # Output: There are X apples and X oranges. (digits replaced with "X")


# ------------------------------------------------------------------------------------------------------------------------------

# Working with external libraries:
# 1. NumPy: A powerful library for numerical computing in Python, providing support for arrays and mathematical functions.
# 2. Pandas: A library for data manipulation and analysis, providing data structures like DataFrames and Series.
# 3. Matplotlib: A plotting library for creating static, animated, and interactive visualizations in Python.
# 4. Scikit-learn: A machine learning library for Python, providing tools for data mining and data analysis.
# 5. TensorFlow: An open-source library for machine learning and deep learning, developed by Google.
# 6. Flask: A lightweight web framework for building web applications in Python.
# 7. Django: A high-level web framework for building robust and scalable web applications in Python.
# 8. Requests: A library for making HTTP requests in Python, simplifying the process of working with APIs and web services.
# 9. BeautifulSoup: A library for web scraping and parsing HTML and XML documents.
# 10. OpenCV: A library for computer vision and image processing in Python.
# 11. Pillow: A library for image processing in Python, providing support for opening, manipulating, and saving image files.
# 12. SQLAlchemy: A SQL toolkit and Object-Relational Mapping (ORM) library for Python, providing a high-level interface for working with databases.
# 13. Pytest: A testing framework for Python, providing tools for writing and running tests.


# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------


# ALL THE BEST FOR YOUR FUTURE !
# I HOPE YOU WILL DO GREAT IN YOUR LIFE !
# KEEP LEARNING AND KEEP GROWING !

# STAY POSITIVE AND STAY MOTIVATED !
# BELIEVE IN YOURSELF AND YOUR ABILITIES !
# YOU CAN ACHIEVE ANYTHING YOU SET YOUR MIND TO !

# NEVER GIVE UP AND ALWAYS STRIVE FOR EXCELLENCE !
# REMEMBER, SUCCESS IS A JOURNEY, NOT A DESTINATION !
# ENJOY THE PROCESS AND HAVE FUN ALONG THE WAY !

# EMBRACE CHALLENGES AND TURN THEM INTO OPPORTUNITIES FOR GROWTH !
# STAY CURIOUS AND KEEP EXPLORING NEW HORIZONS !
# SURROUND YOURSELF WITH POSITIVE INFLUENCES AND SUPPORTIVE PEOPLE !

# LEARN FROM YOUR MISTAKES AND USE THEM AS STEPPING STONES TO SUCCESS !
# STAY HUMBLE AND GRATEFUL FOR ALL THE BLESSINGS IN YOUR LIFE !
# SHARE YOUR KNOWLEDGE AND HELP OTHERS ALONG THE WAY !

# YOU HAVE THE POWER TO MAKE A DIFFERENCE IN THE WORLD !
# BELIEVE IN YOUR DREAMS AND WORK HARD TO MAKE THEM A REALITY !
# STAY FOCUSED AND NEVER LOSE SIGHT OF YOUR GOALS !


# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------


# CREATOR : OJAS MANIYAR.
# DATE : 01/05/2025

# Portfolio : https://ojas-maniyar-portfolio.vercel.app
# LinkedIn : https://www.linkedin.com/in/ojasmaniyar25
# GitHub : https://www.github.com/ojasmaniyar5

# PYTHON FULL STACK DEVELOPER.
# FRONT-END DEVELOPER.
# WEBSITE CREATOR.
# WEBSITE DESIGNER.